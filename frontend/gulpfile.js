const {src, dest, series, parallel, watch} = require('gulp');

const fs = require('fs');
const path = require('path');

const g = {
    gzip: require('gulp-gzip'),
    htmlmin: require('gulp-htmlmin'),
    sass: require('gulp-sass'),
    cleanCSS: require('gulp-clean-css'),
    sourcemaps: require('gulp-sourcemaps'),
    terser: require('gulp-terser'),
    pipeline: require('readable-stream').pipeline,
    clean: require('gulp-clean'),
    concat: require('gulp-concat'),
    mergeStream: require('merge-stream'),
    manifest: require('gulp-manifest3')
// const htmlreplace = require('gulp-html-replace');
};
g.sass.compiler = require('node-sass');

const util = {
    browserSync: require('browser-sync'),
    readDir: require('recursive-readdir'),
    mimeTypes: require('mime-types')
};

const server = util.browserSync.create();

// config
const config = {
    srcDir: './src/',
    vendorDir: './vendor/',
    targetDir: './../src/webapp/',
    distDir: './dist/',
    platformIoFile: './../platformio.ini',

    dirInPlatformIoFile: 'src/webapp/',
    symbolFileName: 'files.h',
    webserverFileName: 'webserver.h',
    platformioStartTag: /^\s*;\s*<Autogenerated>\s*$/gm,
    platformioEndTag: /^\s*;\s*<\/Autogenerated>\s*$/gm
};

function jsTask() {
    return g.pipeline(
        src(path.posix.join(config.srcDir, '*.js')),
        g.concat('app.js'),
        dest(config.distDir),
        g.sourcemaps.init(),
        g.terser(),
        g.gzip({gzipOptions: {level: 9}}),
        g.sourcemaps.write('.'),
        dest(config.distDir));
}

function cssTask() {
    return g.pipeline(
        src(path.posix.join(config.srcDir, '*.scss')),
        g.sourcemaps.init(),
        g.sass().on('error', g.sass.logError),
        g.concat('app.css'),
        dest(config.distDir),
        g.cleanCSS({compatibility: 'ie8'}),
        g.gzip({gzipOptions: {level: 9}}),
        g.sourcemaps.write('.'),
        dest(config.distDir));
}

function htmlTask() {
    return g.pipeline(
        src(path.posix.join(config.srcDir, '*.html')),
        dest(config.distDir),
        g.htmlmin({collapseWhitespace: true}),
        g.gzip({gzipOptions: {level: 9}}),
        dest(config.distDir)
    );
}

function vendorJsTask() {
    return g.pipeline(
        src(path.posix.join(config.vendorDir, '*.js')),
        g.sourcemaps.init(),
        g.concat('vendor.js'),
        dest(config.distDir),
        g.terser(),
        g.gzip({gzipOptions: {level: 9}}),
        g.sourcemaps.write('.'),
        dest(config.distDir)
    );
}

function vendorCssTask() {
    return g.pipeline(
        src(path.posix.join(config.vendorDir, '*.css')),
        g.sourcemaps.init(),
        g.concat('vendor.css'),
        dest(config.distDir),
        g.cleanCSS({compatibility: 'ie8'}),
        g.gzip({gzipOptions: {level: 9}}),
        g.sourcemaps.write('.'),
        dest(config.distDir));
}

function copyTask() {
    return g.pipeline(
        src([path.posix.join(config.distDir, '*.html.gz'),
            path.posix.join(config.distDir, '*.css.gz'),
            path.posix.join(config.distDir, '*.js.gz'),
            path.posix.join(config.distDir, 'appcache.manifest')
        ]),
        dest(config.targetDir));
}

function cleanDistTask() {
    return g.pipeline(
        src(path.posix.join(config.distDir, '**/*'), {read: false, allowEmpty: true}),
        g.clean());
}

function cleanTargetTask() {
    return g.pipeline(
        src(config.targetDir, {read: false, allowEmpty: true}),
        g.clean({force: true}));
}

function replaceFilesInPlatfomrIO(newFiles) {
    const platformIoFileContent = fs.readFileSync(config.platformIoFile, "utf8");
    const startSplit = platformIoFileContent.split(config.platformioStartTag);
    const prefix = startSplit[0];
    const stopSplit = startSplit[1].split(config.platformioEndTag);
    const postfix = stopSplit[1];

    let newContent = prefix + '; <Autogenerated>\n';
    for (let n of newFiles) {
        newContent += '  ' + config.dirInPlatformIoFile + n.replace(/\\/g, '/') + '\n';
    }
    newContent += '; </Autogenerated>\n' + postfix;

    fs.writeFileSync(config.platformIoFile, newContent);
}

function fileListTask(cb) {
    util.readDir(config.targetDir, ['*.txt'], (err, files) => {
        let fileHContent = '// !!!!! AUTO GENERATED, DO NOT EDIT !!!!!\n\n' + '#pragma once\n\n';
        let webserverHContent = '// !!!!! AUTO GENERATED, DO NOT EDIT !!!!!\n\n' + '#pragma once\n\n';
        let platformIoFiles = [];
        for (const f of files) {
            if (f === config.webserverFileName || f === config.symbolFileName) {
                continue;
            }
            const normalized = path.normalize(f);
            const ext = path.extname(normalized).toLowerCase();
            const name = path.basename(normalized);
            const rawName = name.toLowerCase().endsWith('.gz') ? name.substring(0, name.length - 3) : name;
            const relativePath = path.relative(config.targetDir, normalized);
            const symbol = relativePath.replace(/\.|\/|\\|-/g, '_');
            const startSymbol = symbol + '_start';
            const endSymbol = symbol + '_end';
            const mime = util.mimeTypes.lookup(ext);

            // file.h
            fileHContent += '// ' + relativePath + '\n';
            fileHContent += 'extern const char ' + startSymbol + '[] asm("_binary_src_webapp_' + startSymbol + '");\n';
            fileHContent += 'extern const char ' + endSymbol + '[] asm("_binary_src_webapp_' + endSymbol + '");\n\n';

            // webserver.h
            webserverHContent += 'webServer_.on("/' + (rawName === 'index.html' ? '' : rawName) + '", [this]() {\n';
            webserverHContent += '  webServer_.sendHeader("Content-Encoding", "gzip");\n';
            webserverHContent += '  webServer_.send_P(200, "' + mime + '", ' + startSymbol + ', ' + endSymbol + ' - ' + startSymbol + ' - 1);\n';
            webserverHContent += '});\n\n';

            // plaformio.ini
            platformIoFiles.push(relativePath.replace('/\\/g', '#'));
        }
        fs.writeFileSync(path.posix.join(config.targetDir, config.symbolFileName), fileHContent);
        fs.writeFileSync(path.posix.join(config.targetDir, config.webserverFileName), webserverHContent);
        replaceFilesInPlatfomrIO(platformIoFiles);

        cb();
    });
}

function pwaTask() {
    return g.pipeline(
        src([path.posix.join(config.distDir, '*.html'), path.posix.join(config.distDir, '*.js'), path.posix.join(config.distDir, '*.css')], {base: config.distDir}),
        g.manifest({hash: true, preferOnline: false, network: ['*'], filename: 'appcache.manifest'}),
        dest(config.distDir)
    );
}

function reloadTask(cb) {
    server.reload();
    cb();
}

function watchTask() {
    server.init({
        server: {
            baseDir: config.distDir,
        }
    });
    watch(path.posix.join(config.srcDir, '*.html'), series(htmlTask, pwaTask, copyTask, reloadTask));
    watch(path.posix.join(config.srcDir, '*.js'), series(jsTask, pwaTask, copyTask, reloadTask));
    watch(path.posix.join(config.srcDir, '*.scss'), series(cssTask, pwaTask, copyTask, reloadTask));
    watch(path.posix.join(config.vendorDir, '*.js'), series(vendorJsTask, pwaTask, copyTask, reloadTask));
    watch(path.posix.join(config.vendorDir, '*.css'), series(vendorCssTask, pwaTask, copyTask, reloadTask));
}

//
exports.cleanDist = cleanDistTask;
exports.cleanTarget = cleanTargetTask;
exports.clean = parallel(cleanDistTask, cleanTargetTask);
exports.html = htmlTask;
exports.css = cssTask;
exports.vcss = vendorCssTask;
exports.js = jsTask;
exports.vjsc = vendorJsTask;
exports.copy = copyTask;
exports.files = fileListTask;
exports.pwa = pwaTask;
exports.build = series(parallel(cleanDistTask, cleanTargetTask), parallel(jsTask, htmlTask, cssTask, vendorCssTask, vendorJsTask), pwaTask, copyTask, fileListTask);

exports.default = exports.build;
exports.develop = series(exports.build, watchTask);
