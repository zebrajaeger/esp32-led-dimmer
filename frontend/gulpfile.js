const {src, dest, series} = require('gulp');
const gzip = require('gulp-gzip');
const del = require('del');
const readDir = require('recursive-readdir');
const path = require('path');
const fs = require('fs');
const mimeTypes = require('mime-types');

// config
const srcDir = './dist/Esp32LedDimmer/';
const targetDir = './../src/webapp/';
const platformIoFile = './../platformio.ini';

const dirInPlatformIoFile = 'src/webapp/';
const symbolFilePath = targetDir + "files.h";
const webserverFilePath = targetDir + "webserver.h";
const platformioStartTag = /^\s*;\s*<Autogenerated>\s*$/gm;
const platformioEndTag = /^\s*;\s*<\/Autogenerated>\s*$/gm;

// build-code
function cleanTargetTask() {
  return del([targetDir + '*', targetDir + 'assets'], {force: true});
}

function copyTask() {
  return src(srcDir + '**/*')
    .pipe(gzip({gzipOptions: {level: 9}}))
    .pipe(dest(targetDir));
}

function replaceFilesInPlatfomrIO(newFiles) {
  const platformIoFileContent = fs.readFileSync(platformIoFile, "utf8");
  const startSplit = platformIoFileContent.split(platformioStartTag);
  const prefix = startSplit[0];
  const stopSplit = startSplit[1].split(platformioEndTag);
  const postfix = stopSplit[1];

  let newContent = prefix + '; <Autogenerated>\n';
  for(let n of newFiles){
    newContent += '  ' + dirInPlatformIoFile + n.replace(/\\/g, '/') + '\n';
  }
  newContent += '; </Autogenerated>\n' + postfix;

  fs.writeFileSync(platformIoFile , newContent);
}

function fileListTask(cb) {
  readDir(srcDir, ['*.txt'], (err, files) => {
    let fileHContent = '// !!!!! AUTO GENERATED, DO NOT EDIT !!!!!\n\n' + '#pragma once\n\n';
    let webserverHContent = '// !!!!! AUTO GENERATED, DO NOT EDIT !!!!!\n\n' + '#pragma once\n\n';
    let platformIoFiles = [];
    for (const f of files) {
      const normalized = path.normalize(f);
      const ext = path.extname(normalized).toLowerCase();
      const name = path.basename(normalized);
      const relativePath = path.relative(srcDir, normalized) + ".gz";
      const symbol = relativePath.replace(/\.|\/|\\|-/g, '_');
      const startSymbol = symbol + '_start';
      const endSymbol = symbol + '_end';
      const mime = mimeTypes.lookup(ext);

      // file.h
      fileHContent += '// ' + relativePath + '\n';
      fileHContent += 'extern const char ' + startSymbol + '[] asm("_binary_src_webapp_' + startSymbol + '");\n';
      fileHContent += 'extern const char ' + endSymbol + '[] asm("_binary_src_webapp_' + endSymbol + '");\n\n';

      // webserver.h
      webserverHContent += 'webServer_.on("/' + name + '", [this]() {\n';
      webserverHContent += '  webServer_.sendHeader("Content-Encoding", "gzip");\n';
      webserverHContent += '  webServer_.send_P(200, "' + mime + '", ' + startSymbol + ', ' + endSymbol + ' - ' + startSymbol + ' - 1);\n';
      webserverHContent += '});\n\n';

      // plaformio.ini
      platformIoFiles.push(relativePath.replace('/\\/g', '#'));
    }
    fs.writeFileSync(symbolFilePath, fileHContent);
    fs.writeFileSync(webserverFilePath, webserverHContent);
    replaceFilesInPlatfomrIO(platformIoFiles);
    cb();
  });
}

// exports.default = series(cleanTargetTask, copyTask);
exports.clean = cleanTargetTask;
exports.copy = copyTask;
exports.default = fileListTask;
